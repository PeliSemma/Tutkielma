% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[finnish]{tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}
\usepackage{apacite}
\usepackage{mdframed}
\usepackage{minted}
\usepackage{caption}
\usepackage{listings}

\newenvironment{caplab}[2]
{%
  \renewcommand\listingscaption{Koodiliite}%
  \vspace{-5pt}%
  \begin{listing}[H]%
  \caption{#2}%
  \label{#1}%
}
{%
  \vspace{7pt}%
  \end{listing}%
  \vspace{-5pt}%
}

\newenvironment{code}[1]
{%
  \VerbatimEnvironment
  \begin{mdframed}%
  \begin{minted}{#1}%
}
{%
  \end{minted}%
  \end{mdframed}%
  \vspace{-15pt}%
}



% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:

\title{Rust peliohjelmoinnissa}
\author{Victor Bankowski, Antti Karjalainen ja Janne Pulkkinen}
\date{\today}
\level{Seminaariraportti}
\abstract{Rust on moderni Mozillan kehittämä järjestelmäohjelmointikieli. Sen tavoitteena on olla sekä turvallinen että nopea. Tämä on mahdollista käännösaikasten omistajuuden ja lainaamisen käsitteiden avulla.

Rustissa jokaisella on arvolla on yksikäsitteinen omistaja joka on vastuussa sen poistamisesta. Tämä omistajuuden käsite mahdollistaa automaattisen muistinhallinnan ilman roskienkeruuta.

Lainaaminen taas mahdollistaa arvon käytön ilman omistajuuden siirtämistä. Yhdestä arvosta voi olla joko yksi muokattava lainaus tai usea muokkaamaton lainaus. Tämä estää samanaikaisuus- ja muistiongelmia käännösaikaisesti.

Verrattuna perinteisiin järjestelmäohjelmointikieliin, kuten C ja C++:aan, Rustin kirjastovalikoima on vielä lapsenkengissä kielen suhteellisen nuoruuden takia. Rust kuitenki tukee C-kirjastojen käyttöä suoraan FFI-rajapinnan kautta. 

Vaikka Rustille ei ole vielä Unityn tai Unreal Enginen kaltaisia kokonaisvaltaisia pelinkehitystyökaluja, sille on kuitenkin saatavilla useita eri pelinkehitykseen liittyviä kirjastoja. Pelimoottorikirjastoja ovat esimerkiksi Amethyst ja Piston. Grafiikkakirjastoista löytyy sidonnat tunnetuimmille grafiikkarajapinnoille. Lisäksi saatavilla on korkeamman tason grafiikkakirjastoja kuten Gfx-rs ja Glium.

Rustin ominaispiirteet vaikuttavat ohjelmistojen, esimerkiksi pelimoottorien, rakenteellisiin valintoihin. ECS (Entity Component System) on yksi Rustille sopiva pelimoottorirakenne ja siitä on useita toteutuksia on saatavilla. Näistä toteutuksista Specs on suosituin erityisesti sen samanaikaisuus ominaisuuksien takia.}

% The following can be used to specify keywords and classification of the paper:

\keywords{ohjelmointikieli, peliohjelmointi}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):"
% \classification{}

% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
% \numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%


\begin{document}

% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering

\section{Johdanto}

Rust on käännettävä ohjelmointikieli, jonka kehitystä tukee Mozilla-säätiö \cite{servo}. Mozilla käyttää kieltä uuden rinnakkaisuutta hyödyntävän Servo -selainmoottorin ohjelmointiin ja lisäksi sitä käyttävät useat organisaatiot kuten Dropbox, Canonical ja Npm \cite{RustFriends}.

Järjestelmäohjelmointikielenä Rust mahdollistaa korkeaa suorituskykyä ja hallittua muistinkäyttöä vaativien sovellusten kehittämisen. Tästä on hyötyä esimerkiksi käyttöjärjestelmissä ja sulautetuissa järjestelmissä. C ja C++ -kielistä poiketen Rust kuitenkin estää yleisiä muistinhallintaa ja kilpatilanteita koskevia ongelmia. Rust ratkaisee nämä ongelmat käyttämällä muistinhallinnassa omistajuuden (“ownership”) ja lainaamisen (“borrowing”) käsitteitä, jotka estävät mahdolliset virhetilanteet jo ohjelman käännösvaiheessa. Näin Rust ei vaadi virtuaalikoneen tai tulkin käyttöä ohjelman suorituksen aikana.

\section{Historia}

Rust-kielen kehitys alkoi vuonna 2006 Graydon Hoaren sivuprojektina, jollaisena se jatkui yli kolmen vuoden ajan \cite{RustFaq}. Mozilla-säätiö osallistui kehitykseen ensimmäisen kerran vuonna 2009 ja on tukenut ohjelmointikielen kehitystä siitä lähtien. Nykyisin kieltä kehittävä ryhmä -- \textit{The Rust Team} -- jakautuu osaryhmiin, jotka vastaavat kielen eri osa-alueista. Osa-alueisiin kuuluvat esimerkiksi kääntäjän kehittäminen, kielen ominaisuuksien suunnittelu ja dokumentaatio.

Suurimpiin Rustia käyttäviin projekteihin kuuluu Mozillan kehittämä Servo -selainmoottori. Sen tavoitteisiin kuuluu sivun piirtämisen, HTML-datan parsimisen ja muiden verkkoselaimen piiriin kuuluvien tehtävien rinnakkaistaminen \cite{QuantumSuperFastCSSEngine}. Servo-projektiin kuuluva CSS-moottori Stylo on otettu käyttöön Mozilla Firefox -verkkoselaimen uusissa versioissa \cite{StyloIncludedInFirefox}.

\section{Perusteet}

Ohjelmointikieleen tutustuessa on tapana kirjoittaa klassinen ``Hei maailma`` -ohjelma joka tulostaa kyseisen lauseen. Koodiliitteessä \ref{helloworld} on kyseisen ohjelman Rust-toteutus, joka ei poikkea juurikaan muista proseduraalisilla kielillä tehdyistä toteutuksista. Suurin ero on tulostuskomennossa, joka on toteutettu makrolla tekstin muotoilun helpottamiseksi. Koodiliitteessä \ref{helloworld2} on esimerkki tekstin muotoilusta.

Rustissa muuttujat määritellään käyttäen \textbf{let} avainsanaa ja ne eivät ole oletusarvoisesti muokattavissa. Muokattavat muuttujat määritellään käyttäen avainsanayhdistelmää \textbf{let mut}. Muuttujan tyyppi määritellään sen nimen jälkeen kaksoispisteellä erotettuna. Esimerkiksi koodiliitteessä \ref{helloworld2} muuttuja nimeltä \texttt{$s\_luku$} on 32-bittinen etumerkillinen kokonaisluku. 

Useimmissa tapauksissa muuttujan tyypin voi jättää merkitsemättä, koska Rust osaa päätellä sen käännösaikana. Kuitenkin funktioiden parametrien ja palautusarvon tyypit täytyy aina merkata. Funktion palautusarvon tyyppi määritellään \texttt{->} nuolen jälkeen. Koodiliitteessä \ref{factorialiter} olevan funktion parametri ja palautusarvo ovat molemmat 64-bittisiä etumerkittömiä kokonaislukuja.

Rustin \textbf{for}-silmukat ovat \textit{for--each}-tyyppisiä eli niissä käydään kaikki sille annetun iteraattorin alkiot läpi. Esimerkiksi koodiliitteessä \ref{factorialiter} käydään kaikki välin $[1, n+1)$ kokonaislukuarvot läpi.

Rustissa ei tarvitse käyttää \textbf{return} avainsanaa, jos arvo palautetaan funktion lopussa ja tällöin kyseisen rivin puolipiste jätetään pois.

\subsection{Omistajuus}

Muistinhallinta on tärkeä osa ohjelmien toimintaa. Tätä varten monissa kielissä käytetään automaattista roskienkeruuta, joka vähentää ohjelmoijan vastuuta, mutta samalla myös vähentää ohjelmoijan mahdollisuuksia vaikuttaa muistinhallintaan.

Pelimoottoreissa muistinhallinnan optimointi on tärkeää hyvän suorituskyvyn saavuttamiseksi. Tämän takia pelimoottorit toteutetaan usein kielillä, joissa muistinhallinta on manuaalista. Tämän kaltaisissa kielissä jää ohjelmoijan vastuuksi varata ja vapauttaa muisti oikeaoppisesti. Tästä johtuen kyseiset kielet ovat alttiita muistihallintavirheille. \cite{CVE}

Rust-ohjelmointikielessä ei käytetä automaattista roskienkeruuta, mutta siinä ei myöskään jätetä muistinhallintaa täysin ohjelmoijan vastuulle. Tämä on mahdollista, koska Rust takaa sen että jokaisella varatulla muistialueella on yksikäsitteinen omistaja, joka on vastuussa sen vapauttamisesta. Koska Rustissa omistajuus on käännösaikainen käsite, on se yhtä tehokasta kuin manuaalinen muistinhallinta. \cite{TheGoodBook}

Ohjelmointikielen tasolla muuttuja omistaa arvonsa. Kun muuttuja poistuu näkyvyysalueelta, niin sen omistama arvo vapautetaan. Muuttuja voi siirtää omistamansa arvon jollekin muuttujalle tai funktiolle parametriksi, jolloin myös sen omistajuus siirtyy. Tämän jälkeen alkuperäinen muuttuja ei voi käyttää arvoa sillä se ei enää omista sitä.

Liitekoodissa \ref{ownerexample} havainnollistetaan, mitä tapahtuu kun muuttujaa yritetään käyttää sen arvon siirron jälkeen. Virheviestistä nähdään selvästi missä arvon siirto ja missä virheellinen muuttujan uudelleenkäyttö tapahtuvat. Lisäksi viestissä huomautetaan $Copy$-trait toteutuksen puuttumisesta $String$-tyypille. Rustissa siirrot ovat aina muistisiirtoja pinossa. $Copy$-traitin toteuttavat tyypit takaavat, että kaikki niihin liittyvä data sijaitsee siellä. Tämän takia niiden siirrossa tehdään ns. syväkopiointi. \textit{Syväkopiointi}(Deep copy) tarkoittaa kaiken muuttujaan liittyvän datan kopioimista. Syväkopioinnin vastakohta on \textit{pinnallinen kopiointi}(Shallow copy), jossa vain viittaukset kopioidaan. Koska siirto on syväkopio $Copy$-traitin toteuttaville tyypeille, ei tämän tyyppisillä muuttujilla ole siirtosemantiikkaa.

\subsection{Lainaaminen ja elinajat}

Jos Rustissa olisi pelkästään omistajuuden käsite, niin funktioiden pitäisi palauttaa parametrinsa, jotta niitä voitaisiin käyttää uudelleen funktiokutsun jälkeen. Parametrien uudelleenkäyttö on kuitenkin todella yleistä, jonka takia Rustissa on tätä varten käytössä lainaamisen käsite. Sen sijaan että omistajuus siirrettäisiin, arvoa voidaan lainata. Lainauksen aikana alkuperäinen omistaja ei voi käyttää arvoa, mutta se saa sen takaisin käyttöönsä heti, kun lainaus on loppunut. Rustissa on kaksi eri lainaustyyppiä: Muokkaamaton ja muokattava lainaus.

\textit{Muokkaamattomassa lainauksessa} lainaaja ei pysty muokkaamaan lainattua arvoa, mutta lainauksia voi olla useita kappaleita samanaikaisesti (aliasiointi). \textit{Muokattavia lainauksia} saa sen sijaan olla vain yksi arvoa kohden, mutta niitä on mahdollista muokata. Samasta arvosta ei voi myöskään olla muokattavaa ja muokkaamatonta lainausta samanaikaisesti. Nämä säännöt takaavat sen että aliasointia ja muokkaamista ei voi tapahtua samanaikaisesti.

Tällainen aliasoinnin ja muokattavuuden kahtiajako välttää muistiturvallisuusongelmia kuten iteraattorin mitätöimistä (iterator invalidation). Koodiliitteessä \ref{iterationexample} on esimerkki iteraattorin mitätöitymistilanteesta. Virheviestistä näkee kuinka lainauksen säännöt estävät ongelman käännösaikana. Useimmissa kielissä, kuten Javassa ja C++:ssa, vastaavanlainen koodi kääntyisi ja siitä aiheutuvat ongelmat huomattaisiin vasta ajonaikana. Java heittäisi tässä tapauksessa poikkeuksen, kun taas C++:ssa siitä voisi pahimmassa tapauksessa seurata se että iteraattori osoittaisi vapautettuun muistiin. 

Lainaaminen auttaa myös estämään kilpatilanteista johtuvia samanaikaisuusongelmia. Kilpatilanne voi tapahtua vain, jos useampi taho pääsee samanaikaisesti käsiksi arvoon ja ainakin yksi niistä muokkaa sitä. Rustin lainaamissäännöt nimenomaan eivät salli tätä.

Kuten jo aiemmin mainittiin, arvot vapautetaan aina silloin kun niiden omistajat poistuvat näkyvyysalueiltansa. Vapauttamisen jälkeen kaikki arvoon liittyvät lainaukset osoittaisivat vapautettuun muistiin eli ne olisivat niin sanottuja roikkuvia viittauksia (Dangling references). Koodiliitteessä \ref{dangling} on esimerkki juuri tällaisesta virheellisestä lainauksesta. Jotta tätä ei tapahtuisi, lainauksien oikeellisuutta pitää seurata jollain tavalla. 

Rustissa kaikilla lainauksilla on tätä varten \textit{elinaika}, jonka täytyy aina olla lyhyempi kuin sen lainaaman arvon elinaika. Elinaika pystytään useimmissa tapauksissa päättelemään koodista automaattisesti. Joskus tämä ei ole kuitenkaan mahdollista, jolloin ohjelmoijan täytyy merkata se koodissa erillisellä elinaikamerkillä. Koodiliite-esimerkissä \ref{lifetimes} on kaksi funktiota. Ensimmäisessä ei ole elinaikamerkintää, jonka takia Rust ei tiedä kummasta lainauksesta palautusarvona oleva lainaus tulee. Elinaikamerkatussa versiossa taas elinaikamerkintä yhdistää parametrin $b$ elinajan palautusarvon elinaikaan, jolloin Rust tietää kuinka pitkään palautusarvoa voi käyttää.

\section{Vertailu C-kieliin}

\subsection{Kehitystyökalut}

C ja C++ -ohjelmointikielet ovat Rustin tavoin käännettäviä ohjelmointikieliä, jotka soveltuvat suorituskykyä vaativien sovelluksien kehittämiseen. Tällaisiin sovelluksiin kuuluvat muun muassa käyttöjärjestelmät, sulautetut järjestelmät ja pelimoottorit, joista esimerkiksi \textit{Unity} ja \textit{Unreal Engine} on kirjoitettu C++ -kieltä käyttäen. Rustille on saatavilla pelimoottorikirjastoja kuten Piston ja Amethyst, mutta Unityn tai Unreal Enginen kaltaisia kokonaisvaltaisia pelinkehityskokonaisuuksia ei toistaiseksi ole saatavilla Rust-kielelle.\cite{AreWeGameYetEngines}

Rust-lähdekoodin kääntämiseen käytetään rustc -työkalua, joka on kirjoitettu Rust-kielellä. Kääntäjä hyödyntää LLVM-kääntäjäinfrastruktuurin työkaluja, ja hyötyy siten kyseistä projektia koskevista suorituskykyparannuksista. \cite{RustFaq} C++ -kielestä poiketen Rustille ei ole kuitenkaan saatavilla vaihtoehtoisia kääntäjiä. Laajassa käytössä oleviin C++ -kielen kääntäjiin kuuluu muun muassa LLVM-projektin \textit{Clang}, \textit{GNU GCC} ja \textit{Intel C++ Compiler}.

Koska Rust-kieleen ei kuulu ajonaikaista virtuaalikonetta tai tulkkia, Rust-koodia on C-kielten tavoin mahdollista hyödyntää korkeamman tason kielissä kuten Pythonissa tai Rubyssa. Tässä tapauksessa sovelluksen tehokasta suorituskykyä ja muistinkäyttöä vaativat osat voidaan kirjoittaa Rustilla.\cite{RustInsideOtherLanguages} C-kielellä kirjoitettuja kirjastoja on myös mahdollista käyttää Rustilla toteuttamalla kirjastolle sidonnat, jotka käyttävät kirjaston funktioita FFI (\textit{Foreign Function Interface}) -rajapinnan kautta. C-kielellä kirjoitettuja kirjastoja ei siis tarvitse kirjoittaa uudelleen, jotta niitä voidaan hyödyntää Rust-kielessä. Kuitenkaan C:llä kirjoitetut rajapinnat eivät suoraan käytettyinä noudata rustin turvakäytänteitä. Tämän takia suorien sidontakirjastojen lisäksi C-kirjastoille tehdään usein Rustille idiomaattisempia rajapintakirjastoja, jotka pyrkivät estämään alkuperäisen rajapinnan väärinkäytön ja siitä johtuvat muistivirheet.

\subsection{Käyttöjärjestelmät}

C++ -kieli ja sitä edeltävä C-kieli ovat yleisiä käyttöjärjestelmien ohjelmointikielinä: \textit{Microsoft Windows} on ohjelmoitu C++ -kielellä, \textit{FreeBSD} on ohjelmoitu käyttäen sekä C että C++-kieliä ja \textit{Linux} käyttää C-kieltä. Rust olisi muistinhallintansa puolesta otollinen käyttöjärjestelmäytimien ohjelmointiin, jossa muistinhallintavirheillä voi olla vakavia seurauksia järjestelmän vakauden ja tietoturvallisuuden kannalta. \textit{Redox} on Rust-kielellä kirjoitettu mikroydinrakennetta noudattava käyttöjärjestelmä.\cite{WhatRedoxIs} Redox on vielä aikaisessa kehitysvaiheessa eikä siten sovellu jokapäiväiseen käyttöön.

\textit{Tock} on Rust-kielellä toteutettu sulautettu käyttöjärjestelmä.\cite{OwnershipIsTheft} Tavallisista käyttöjärjestelmistä poiketen sulautetuissa käyttöjärjestelmissä on tiukat resurssivaatimukset. Tock on suunniteltu muun muassa toimimaan ympäristössä, jossa käytössä on vain 64 kilotavua keskusmuistia. Rustin käyttö on vaikuttanut Tockin käyttöjärjestelmäytimessä tehtyihin valintoihin sen muistinhallinnan takia.\cite{CaseForWritingKernel}

Rust tukee virallisesti 32- ja 64-bittisiä Microsoft Windows, \textit{Linux} ja \textit{OS X} -käyttöjärjestelmiä.\cite{RustPlatformSupport} Muille alustoille, kuten ARM-arkkitehtuurille ja \textit{iOS} ja \textit{Android} -mobiilikäyttöjärjestelmille on rajatumpi tuki: alustoille on saatavilla valmiiksi käännetyt stadardikirjastot ja kehitystyökalut, mutta automatisoituja testejä ei ajeta niille julkaisun yhteydessä eikä niitä voi siten pitää yhtä toimintavarmoina. iOS ja Android -käyttöjärjestelmille on olemassa virallisesti tuetut C ja C++ -kielille tarkoitetut kehitystyökalut. Esimerkiksi \textit{Android NDK} sallii sovellusten kehittämisen C ja C++ -kieliä käyttäen, tarjoten myös rajapinnat esimerkiksi 3D-piirtämistä, äänentoistoa ja säikeiden hallintaa varten.\cite{AndroidNDK}

\section{Peliohjelmointi Rustilla}

\subsection{Pelimoottorit}
Kuten aiemmin jo mainittiin Rustissa ei ole vielä Unityn tai Unrealin kaltaisia pelimoottoreita. Kuitenkin pelinkehitystä varten Rustille on kehitteillä pelimoottorikirjastoja. Tälläisiä ovat esimerkiksi Piston ja Amethyst. 

Näistä Piston on täysin modulaarinen pelimoottori eli se on käytännössä kokoelma erilaisia pelinkehityskirjastoja. Se koostuu muutamasta ydinkirjastosta ja isosta määrästä apukirjastoja. Ydinkirjastoihin kuuluvat \textit{pistoncore-input} syötteenhallintakirjasto, \textit{pistoncore-window} ikkunointikirjasto ja \textit{pistoncore-event\texttt{\_}loop} pelisilmukanhallintakirjasto. Apukirjastojen joukosta löytyy esimerkiksi \textit{vecmath}, joka on yksinkertainen vektorimatematiikkakirjasto, \textit{piston3d-cam} 3D-kameran hallintakirjasto ja \textit{texture\texttt{\_}packer} tekstuurinpakkauskirjasto. Pistonin modulaarisuudesta kertoo se että sen ikkunointi- sekä 2d-grafiikkakirjastoilla on useampi backend.

Amethyst\cite{Amethyst} taas on dataorientoitunut ja dataohjattu pelimoottori, joka on saanut inspiraationsa Bitsquid Enginestä (nykyisin Autodesk Stingray)\cite{AmethystReadme}. \textit{Dataorientoitunut ohjelmointi} on ohjelmointiparadigma, joka keskittyy dataan. Siinä kiinnitetään erityisesti huomiota datan tyyppiin, sen esitysmuotoon muistissa ja kuinka se prosessoidaan. \textit{Dataohjattu suunnittelumalli} tarkoittaa taas sitä että ohjelman logiikkaa ohjautuu mahdollisimman paljon ulkoisen datan perusteella. Tällöin on mahdollista muokata ohjelman toimintaa ilman sen uudelleenkääntämistä. \cite{AmethystGlossary}

Amethystin ominaisuuksiin kuuluvat yksinkertainen pelitilan hallinta pinoautomaatilla, skriptausrajapinta, gfx-rs -kirjastoon pohjautuva renderöinti ja specs-kirjastoon pohjautuva ECS-malli.

Piston ja Amethyst noudattavat kummatkin hyvin Unixmaista lähestymistapaa: molemmat koostuvat pienistä integroiduista palasista. Amethyst muodostaa näistä kahdesta selkeämmän kokonaisuuden kun taas Piston on modulaarisempi kokonaisuus erilaisia kirjastoja.

\subsection{ECS}
Rustin omistajuuden ja lainaamisen mekanismit estävät aliasioinnin ja muokattavuuden samanaikaisuuden. Tämä vaikuttaa pelimoottorin suunnittelussa tehtäviin rakenteellisiin valintoihin. Esimerkiksi syklisten viittausten käyttö vaikeutuu huomattavasti. Tällaisia viittauksia voi esiintyä esimerkiksi maailman ja sen sisältävien olioiden välillä. Rustissa sykliset viittaukset voidaan toteuttaa älyosoitin-yhdistelmillä, mutta niiden käyttö vähentää suoritustehoa lisäämällä ajonaikaisia tarkistuksia ja lisäksi siirtää osan vastuusta ylläpitää lainaamisen sääntöjä ohjelmoijalle.

Vaihtoehtoinen tapa jäsennellä peli on käyttää ECS (Entity Component System) -mallia, jossa peli koostuu entiteeteistä, komponenteista ja järjestelmistä.

\textit{Komponentit} (Component) ovat datasäiliöitä, joiden avulla ylläpidetään pelitilaan liittyviä tietoja. Esimerkiksi pelihahmon sijainti, tekstuuri ja tiimi voidaan tallentaa komponentteina.

\textit{Entiteetit} (Entity) ovat tunnuksia, joihin voidaan liittää vaihteleva määrä eri komponentteja. Pelihahmot, ammukset ja partikkeligeneraattorit ovat esimerkkejä mahdollisista entiteeteistä. Partikkeligeneraattoriin ja pelihahmoihin liittyy todennäköisesti hyvin erilaiset komponentit. Esimerkiksi partikkeligeneraattori ei tarvitse välttämättä tiimikomponenttia, mutta se voi tarvita komponentteja partikkelien käyttäytymiseen liittyen, joita taas pelihahmot eivät tarvitse.

\textit{Järjestelmät} (System) prosessoivat entiteettejä lukemalla tai muokkaamalla niihin liittyviä komponentteja. Niiden käsittelemiltä entiteeteiltä täytyy löytyä systeemin vaatimat komponentit. Esimerkiksi yksinkertainen fysiikkajärjestelmä voisi vaatia entiteeteiltä sijainti-, nopeus- ja kiihtyvyyskomponentit toimintaansa varten. Toisaalta renderöintijärjestelmä voisi sen sijaan vaatia sijainti-, tekstuuri-, malli- ja sävytinkomponentit.

ECS-lähestymistapa on tehokas, koska eri komponentit voidaan tallentaa omiin yhtenäisiin tietorakenteisiinsa. Tämä on järkevää välimuistitehokkuuden kannalta, sillä järjestelmät käsittelevät peräkkäin suuren määrän samantyyppisiä komponentteja. ECS tekee myös selvän jaon datan ja toiminnallisuuden välillä, joka lisää pelimoottorin modulaarisuutta.

Rustissa on useita ECS-kirjastoja, joista yksi suosituimpia on \textit{Specs} (Specs Parallel ECS)\cite{AreWeGameYetEcs}. Specsiä käytetään esimerkiksi aiemmin mainitussa Amethyst-pelimoottorissa. 

Specs pystyy ajamaan järjestelmiä samanaikaisesti, jos niiden lukemis- ja muokkausvaatimukset eivät ole päällekkäisiä komponenttisäiliöille. Siinä järjestelmille voidaan myös asettaa riippuvuussuhteita, jotka vaikuttavat järjestelmien ajamisjärjestykseen. Lisäksi Specsissä pystyy samanaikaistamaan komponenttiyhdistelmien läpikäyntiä järjestelmien sisällä.

Specissä eri komponenteille voidaan valita erilaisia säiliöitä niiden käyttötarkoituksen mukaan. $VecStorage$ käyttää sisäisesti yksinkertaista dynaamisesti kasvavaa taulukkoa, joka on muistitehokas, kun komponentti löytyy lähes kaikilta entiteeteiltä. 

Jos komponentti ei löydy tarpeeksi monelta entiteetiltä, $VecStorage$:n sisäiseen taulukkoon jää suuria aukkoja, koska siinä entiteettien tunnukset ovat suoraan taulukon indeksejä. $DenseVecStorage$ korjaa tämän ongelman käyttämällä uudelleenohjaustaulukkomenetelmää. Siinä on datataulukon lisäksi kaksi aputaulukkoa, joiden avulla varsinainen data pystytään tallentamaan tiiviisti.

$HashMapStorage$:ssa komponentit tallennetaan hajautustauluun niin että entiteetti toimii avaimena ja komponentti arvona. Sen iteroiminen on hitaampaa, mutta se on muistitehokkaampi, jos komponentti liittyy vain pieneen määrään entiteettejä.  

Komponentti, joka ei sisällä varsinaista dataa vaan toimii vain tunnistimena, kannattaa se säilöä $NullStorage$:ssa. Esimerkiksi jonkun tietyn vihollistyypin tekoälyjärjestelmä voi tunnistaa kaikki oikeantyyppiset entiteetit tämänlaisen komponentin avulla. 

\subsection{Grafiikka}

Rustille on tehty suoria sidoksia yleisimmille grafiikkarajapinnoille, kuten OpenGL:lle ja Vulkanille. Rustille on myös olemassa grafiikkakirjastoja, jotka käyttävät näitä suoria sidoksia ytimessään, mutta tarjoavat Rust-ohjelmoijalle idiomaattisemman rajapinnan. Tällaisia kirjastoja ovat esimerkiksi gfx-rs ja glium.

\textit{Gfx-rs} on abstrahoitu grafiikkakirjasto, joka noudattaa frontend-backend kahtiajakoa. Gfx-kirjaston frontend-osio on Vulkanin kaltainen, mutta sitä abstraktimpi rajapinta. Sille on toteutettu backendit Vulkanille, Direct3D 12:lle, Metalille ja OpenGL 2.1+/ES2:lle. Gfx on yksi suosituimpia grafiikkakirjastoja ja sitä tukevat esimerkiksi aiemmin mainitut Piston ja Amethyst -pelimoottorit.

\textit{Glium} on turvallinen rajapintakirjasto OpenGL:lle. Se pyrkii piilottamaan OpenGL:n tilakonemaisen toiminnan ja tarjoamaan Rust-kielelle soveltuvan tilattoman rajapinnan sen sijaan. Esimerkiksi OpenGL:n virhetilanteita pyritään välttämään täysin käännösaikaisesti. Vaikka Gliumin alkuperäinen kehittäjä on siirtynyt kehittämään Vulkano-kirjastoa, sen yhteisö ylläpitää sitä edelleen.

\section{Yhteenveto}

Seminaaritutkielmassa selostettiin Rustin historiaa ja sen tärkeitä periaatteita ohjelmoijan kannalta. Lisäksi tutkielmassa analysoitiin Rustille saatavia kehitystyökaluja sekä ohjelmistokehityksessä että peliohjelmoinnissa.

Rustille on nuoren ikänsä takia olemassa vähemmän kehitystyökaluja ja kirjastoja kuin muilla vakiintuneilla ohjelmointikielillä. Tästä huolimatta Rustille on saatavilla useisiin eri käyttötarkoituksiin, kuten peliohjelmointiin, soveltuvia kirjastoja. Ongelmaksi saattaa tosin muodostua kirjastojen ja työkalujen jatkuva muutos verrattuna alalla vakiintuneisiin kirjastoihin ja pelimoottoreihin. 

Rust vaikuttaa ominaisuuksiensa puolesta sopivalta suorituskykyä vaativien ohjelmien, kuten pelien ja pelimoottorien kirjoittamiseen. Toisaalta, Rustin säännöt voivat aiheuttaa hankaluuksia tietyissä tilanteissa esimerkiksi, jos olioiden välillä on monimutkaisia viittaussuhteita. Tämä edellyttää usein muista kielistä poikkeavan lähestymistavan käyttöä.


% --- References ---
%
% bibtex is used to generate the bibliography. The babplain style
% will generate numeric references (e.g. [1]) appropriate for theoretical
% computer science. If you need alphanumeric references (e.g [Tur90]), use
%
% \bibliographystyle{babalpha-lf}
%
% instead.

\bibliographystyle{apacite}
\bibliography{references-fi}


% --- Appendices ---

% uncomment the following

\newpage
\appendix

\section{Koodiesimerkit}

\begin{caplab}{helloworld}{Tulostaa "Hei maailma"}
\begin{code}{rust}
fn main() {
    println!("Hei maailma");
}
\end{code}
\begin{code}{text}
$ cargo run
Hei maailma
\end{code}
%$
\end{caplab}

\begin{caplab}{helloworld2}{Tulostaa satunnaisluvun}
\begin{code}{rust}
fn main() {
    let s_luku: i32 = 4; // Valittu reilulla nopanheitolla.
    println!("Satunnaislukusi on {}", s_luku);
}
\end{code}
\end{caplab}

\begin{caplab}{factorialiter}{Funktio joka laskee $n!$ iteratiivisesti.}
\begin{code}{rust}
fn factorial(n: u64) -> u64 {
    let mut result = 1;
    for i in 1..(n + 1) {
        result *= i;
    }
    return result;
}
\end{code}
\end{caplab}

\begin{caplab}{factorialrec}{Funktio joka laskee $n!$ rekursiivisesti.}
\begin{code}{rust}
fn factorial(n: u64) -> u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n-1)
    }
}
\end{code}
\end{caplab}

\begin{caplab}{ownerexample}{Muuttujan käyttö omistajuuden siirron jälkeen.}
\begin{code}{rust}
fn main() {
    let mut string = String::from("Hello, ");
    add_world(string);
    add_world(string);
}

fn add_world(mut string: String) {
    string.push_str("World!");
}
\end{code}
\begin{code}{text}
$ cargo run
error[E0382]: use of moved value: 'string'
 --> src/main.rs:4:15
  |
3 |     add_world(string);
  |               ------ value moved here
4 |     add_world(string);
  |               ^^^^^^ value used here after move
  |
  = note: move occurs because 'string' has type 
  'std::string::String', which does not implement 
  the 'Copy' trait
\end{code}
%$
\end{caplab}

\begin{caplab}{iterationexample}{Iteraatio invalidaatio}
\begin{code}{rust}
fn main() {
    let mut list = vec![1,2,4,5,6,4,6,7];
    
    for n in &list {
        list.push(*n);
    }
}
\end{code}
\begin{code}{text}
$ cargo run
error[E0502]: cannot borrow `list` as mutable because it
is also borrowed as immutable
 --> src/main.rs:6:9
  |
5 |     for n in &list {
  |               ---- immutable borrow occurs here
6 |         list.push(*n);
  |         ^^^^ mutable borrow occurs here
7 |     }
  |     - immutable borrow ends here
\end{code}
%$
\end{caplab}

\begin{caplab}{dangling}{Roikkuva viittaus}
\begin{code}{rust}
fn ei_toimi<'a>() -> &'a String {
    let merkkijono = String::from("ei toimi");
    &merkkijono
}
\end{code}
\begin{code}{text}
$ cargo run
error[E0597]: `merkkijono` does not live long enough
 --> src/main.rs:3:6
  |
3 |     &merkkijono
  |      ^^^^^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as 
defined on the function body at 1:1...
 --> src/main.rs:1:1
  |
1 | / fn ei_toimi<'a>() -> &'a String {
2 | |     let merkkijono = String::from("ei toimi");
3 | |     &merkkijono
4 | | }
  | |_^
\end{code}
%$
\end{caplab}

\begin{caplab}{lifetimes}{Elinaikamerkinnän tarpeellisuus}
\begin{code}{rust}
fn ei_toimi(a: &String, b: &String) -> &String {
    println!("{}", a);
    b
}

fn toimii<'b>(a: &String, b: &'b String) -> &'b String {
    println!("{}", a);
    b
}
\end{code}
\begin{code}{text}
$ cargo run
error[E0106]: missing lifetime specifier
 --> src/main.rs:1:40
  |
1 | fn ei_toimi(a: &String, b: &String) -> &String {
  |                                        ^ expected
                                             lifetime
                                             parameter
  |
  = help: this function's return type contains a borrowed
  value, but the signature does not say whether it is
  borrowed from `a` or `b`
\end{code}
%$
\end{caplab}

\end{document}
